package vertx.jdbc

import io.vertx.core.Vertx
import io.vertx.core.json.JsonArray
import io.vertx.core.json.JsonObject
import io.vertx.ext.jdbc.JDBCClient
import org.apache.ignite.IgniteJdbcThinDriver
import org.apache.ignite.internal.jdbc.thin.JdbcThinConnection
import org.apache.ignite.internal.jdbc.thin.JdbcThinUtils
import org.apache.ignite.internal.util.typedef.F
import java.sql.*
import java.util.*
import java.util.logging.Logger


fun main(args: Array<String>) {
    val vertx = Vertx.vertx()
    val config = JsonObject()
    config.put("url", "jdbc:ignite:custom://127.0.0.1:10800")
//    config.put("driver_class", "vertx.jdbc.CustomDriver")
    val client = JDBCClient.createShared(vertx, config)
    client.getConnection {
        if (it.succeeded()) {
            var conn = it.result()
            conn.updateWithParams("INSERT INTO Person(id, name, age, address) VALUES(?,?,?,?)",
                    JsonArray().add(UUID.randomUUID().toString())
                            .add("zhangsan")
                            .add(18)
                            .add("Shanghai")) { rs ->
                if (rs.failed()) {
                    println(rs.cause())
                } else {
                    conn.query("SELECT * FROM Person") { rs ->
                        if (rs.succeeded()) {
                            var r = rs.result()
                            println(r.toJson())
                        }
                    }
                }
            }
        }
    }
}

class CustomDriver : IgniteJdbcThinDriver(), Driver {

    val URL_PREFIX = "jdbc:ignite:custom://"
    val PROP_PREFIX = "ignite.jdbc."

    companion object {
        init {
            DriverManager.registerDriver(CustomDriver())
        }
    }

    override fun acceptsURL(url: String): Boolean {
        return url.startsWith(URL_PREFIX)
    }

    override fun connect(url: String, props: Properties?): Connection? {
        if (!acceptsURL(url))
            return null

        val u = url.replace("custom", "thin")
        val method = javaClass.superclass.getDeclaredMethod("parseUrl", String::class.java, Properties::class.java)
        method.isAccessible = true
        val schema = method.invoke(this, u, props) as String?
        val conn = CustomJdbcThinConnection(u, schema, props)
        return conn
    }
}

class CustomJdbcThinConnection(url: String, schema: String?, props: Properties?) : JdbcThinConnection(url, schema, props) {
    override fun prepareStatement(sql: String?, autoGeneratedKeys: Int): PreparedStatement {
        return super.prepareStatement(sql)
    }
}